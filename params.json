{"name":"Web Sockets","tagline":"Blog Post Describing Different Ways of Transporting Data over the Web, with a particular focus on WebSockets","body":"\r\n**Transporting Data Over the Web**\r\n\r\nI am currently a student taking General Assembly’s Programming Bootcamp in DC and recently created an application for one of our projects using a lot Ajax calls to our backend and a third Party API in order to create a real-time, single page application. I had very little exposure to Ajax or Single Page Applications prior to starting this project and wanted to give a broad overview for any other fellow beginners starting out as well!\r\n\r\nIn this blog post I will be discussing a few different ways of pushing data over the web between the client and the server, and then implement a simple messaging chat application using Nodejs, Express, and Socket.io.\r\n\r\nLet's start by disscuing the foundation for all data communications over the web, the HTTP protocol.\r\n\r\n**Summary of HTTP**\r\n\r\nThroughout my time during GA's web immersive, we have especially focused on creating RESTful applications, focused on HTTP requests. \r\n\r\nTo further explain, HTTP is a protocol for transmitting data over the web. For example, when a user wants to make a purchase off Amazon and types in and submits the URL http://www.amazon.com/, an HTTP request is sent to a web server. \r\n\r\nHTTP behaves as a request-response protocol in the client-server model. The client(the browser in the example above) submits an HTTP request message to the server. The server, may provide HTML files, content, or even perform additional functions on behalf of the client, then returns a response message back. The response will contain the requested information if available in it's message body along with a completion status information. \r\n\r\nHowever, HTTP is considered to be a \"stateless protocol\", but what does that mean exactly?\r\n\r\nA web (HTTP) server does not remember previous requests from a user, and treats each request independently. There is no recorded continuity, and the server does not retain session information. Because of this, applications must implement another layer on top of HTTP to establish state, which is typically accomplished using session cookies. Websites maintain record of users by cookies, which are passed back and fourth for every request. \r\n\r\nMoreover, in order to send data asynchrously through an HTTP request, developers created the XMLHttpRequest object or jquery's version called Ajax.\r\n\r\n**What is Ajax?**\r\n\r\nAjax, stands for Asynchronous JavaScript and XML, and consists of small exchanges of data from the client to the the server, so that the entire web page does not have to be reloaded each time the user makes a change. As developers we want a way to make requests to the server from the client side without a full page refresh, utlimately to make our applications faster and improve user experience. \r\n\r\nBut what if the core goal of our application is to provide continous real time updates? What if we are creating an application that displays real time sports and game updates?\r\n\r\nWe could use Ajax and “polling” to accomplish this by sending periodic requests for updates to the server, and dynamically manipulating the DOM to reflect those changes. This would essentially create a connection and keep it open for a period of time in which the client can receive data from server. \r\n\r\nWe have many options as developers with strong Front-End Frameworks such as Angular which help making Ajax requests a lot easier or additional APIs to assist in these requests. \r\n\r\nHowever, this seems like an efficient way to grab changes from our server. One answer to this problem is are WebSockets, made available through HTML5, which allow an open connection to persist between the client and server in which both can send data at any time. \r\n\r\n**What are Web Sockets?**\r\n\r\nWebSockets are a TCP based Protocol application that establishes a single, bi-directional connection between the client and server, allowing full duplex, persistent messages to be instantously distributed. Once a connection is established, it stays open as long as needed. Ajax is a one-way request that's always intiated by the client, and when the server has sent the response, the connection will close. However with WebSockets both the client and server can send requests and the connection is kept open. Because WebSockets are built on the TCP protocol, which is a stateful protocol, we can accomplish this connection. \r\n\r\nAs you can imagine, this is pretty powerful when we need to create applications that require real-time data. \r\n\r\nBelow, we are going to be using one API available, Socket.io which allows us to easily establish a WebSocket in our application. We are going to be using Nodejs and Expressjs along side Socket.io to build a simple chat messaging application. \r\n\r\nFirst please make sure you have Node installed on your computer. If you do not, you will need to install it first before continuing https://nodejs.org/en/. \r\n\r\n**Chat Messaging App Example**\r\n\r\nLet's create a new directory on our local computers and initialize npm. If your new to Node or npm, feel free to just hit enter for all of the metadata questions, as we can edit it later on in the package.json file. \r\n\r\n```\r\n$ npm init\r\n```\r\nAfter we have initlized npm, let's make sure we install and save Express as a dependency. \r\n\r\n```\r\n$ npm install express --save\r\n```\r\nNow that we have express installed, saved, and added to our package.json file, we can begin by creating the files an folders we will need for this application. We will create need to create a main JavaScript file, which we will call index.js, which will define and establish all of our dependencies for our express application.\r\n\r\n```\r\n$ touch index.js\r\n```\r\nIn our index.js we need to include the following:\r\n\r\n```js\r\nvar express = require(\"express\");\r\nvar app = express();\r\nvar http = require('http').Server(app);\r\n\r\napp.get('/', function(req, res){\r\n  res.send('<h1>Hello world</h1>');\r\n});\r\n\r\nhttp.listen(4000, function(){\r\n  console.log('listening on port 4000');\r\n});\r\n\r\n```\r\nTo run express from your command line, just type node index.js or use nodemon and you should see listing on port 4000 display on your terminal. If you do not have nodemon install you can easily install it gobally on your computer. This will automatically restart the server each time you make changes:\r\n\r\n```\r\n$ npm install -g nodemon\r\n```\r\n\r\nNow, go to your browser and enter in localhost:4000 and you should see hello world displaying as well. \r\n\r\nGreat! Now that the basics are configured, let’s instead create an index.html file for our html content instead of passing in the string for the route. We can do this through the following commands below. \r\n\r\nFor the purpose of this application, we are going to create a public directory which will contain all of our static files including our index.html, script.js, and stylesheet. \r\n\r\n```\r\n$ mkdir public\r\n$ cd public\r\n$ touch index.html\r\n$ mkdir js\r\n$ touch js/script.js\r\n$ mkdir css\r\n$ touch css/style.css\r\n```\r\nIn order to render the index.html we need to call Express Middleware to look into the public directory and change our route:\r\n\r\n```js\r\napp.use(express.static(__dirname + '/public'));\r\n\r\napp.get('/', function(req, res){\r\n  res.render(\"index.html\");\r\n});\r\n```\r\n\r\nIn our main index.html file we need to add the following and make sure to link our stylesheet and script files:\r\n\r\n```html\r\n\r\n<!DOCTYPE html>\r\n<html>\r\n  <head>\r\n    <meta charset=\"utf-8\">\r\n    <title>Chat Message App</title>\r\n    <script src=\"js/script.js\"></script>\r\n    <link rel=\"stylesheet\" href=\"css/style.css\" type=\"text/css\">\r\n  </head>\r\n  <body>\r\n    <ul class=\"messages\"></ul>\r\n    <form action=\"\">\r\n      <input id=\"msg\" autocomplete=\"off\" /><button>Send</button>\r\n    </form>\r\n  </body>\r\n</html>\r\n```\r\nAnd in our style.css file:\r\n\r\n```css\r\n* {\r\n  margin: 0;\r\n  padding: 0;\r\n  box-sizing: border-box;\r\n}\r\nbody {\r\n  font: 16px Helvetica, Arial;\r\n}\r\nform {\r\n  background: #000;\r\n  padding: 3px;\r\n  position: fixed;\r\n  bottom: 0;\r\n  width: 100%;\r\n}\r\nform input {\r\n  border: 0;\r\n  padding: 10px;\r\n  width: 90%;\r\n  margin-right: .5%;\r\n}\r\nform button {\r\n  width: 9%;\r\n  background: rgb(130, 224, 255);\r\n  border: none;\r\n  padding: 10px;\r\n}\r\n.messages {\r\n  list-style-type: none;\r\n  margin: 0;\r\n  padding: 0;\r\n}\r\n.messages li {\r\n  padding: 5px 10px;\r\n}\r\n.messages li:nth-child(odd) {\r\n  background: #eee;\r\n}\r\n```\r\nNow that we set up our index.html file and stylesheet, it's time to config socket.io. First, we need to install and save socket.io to our package.json file. \r\n```\r\n$ npm install socket.io --save \r\n```\r\n\r\nIn our main application index.js, we need to require socket.io. In this example we are attaching socket.io to an HTTP server listening on port 4000. \r\n\r\n```js\r\nvar io = require(\"socket.io\")(http);\r\n\r\nio.on(\"connection\", function(socket){\r\n  console.log(\"Socket.io has been connected!\");\r\n});\r\n\r\n```\r\n\r\nAnd in our index.html file we need to add both jQuery and socket.io script tags:\r\n\r\n```html\r\n<script src=\"/socket.io/socket.io.js\"></script>\r\n<script src=\"http://code.jquery.com/jquery-1.11.1.js\"></script>\r\n<script src=\"js/script.js\"></script>\r\n```\r\nFinally, in our script.js, we need to declare a socket variable to call socket.io:\r\n\r\n```js\r\n\r\n$(document).ready(function(){\r\n  var socket = io(); \r\n});\r\n```\r\nRestart your server, and you should see that socket.io has been connected. Now let's actually grab the content of the message input and have append it to the DOM when a user click's send. Add this to our script.js file after we have declared socket as a variable.\r\n\r\n```js\r\n\r\n$(\"button\").on(\"click\", function(){\r\n    socket.emit(\"message\", $(\"#msg\").val());\r\n    $(\"#msg\").val(\"\");\r\n    return false;\r\n  });\r\n\r\n  socket.on(\"message\", function(msg){\r\n    $(\".messages\").append($(\"<li></li>\").text(msg));\r\n  });\r\n```\r\n\r\nNow we have all the code written on the client side, let's update our back end to recieve the message. \r\n\r\n```js\r\n\r\nio.on(\"connection\", function(socket){\r\n  socket.on('message', function(msg){\r\n    io.emit(\"message\", msg)\r\n    console.log('message:' + msg);\r\n  });\r\n});\r\n```\r\n\r\nWith socket.io, .emit method is available which emits an event to the socket identified by the string name to all connected clients. Both of the following synatax would work correctly in our example: \r\n\r\n```js\r\nio.sockets.emit();\r\nio.emit();\r\n```\r\n\r\nAlso, we are sending \"message\" consistently on the client and server, but please note you could name this anything including \"pizza\" and as long as it's consistent, it will work the same. Socket.io allows you to do this and create custom events. \r\n\r\nFinally, at localhost://4000, you sould be able to send messages that appear on your application's webpage. Socket.io's documentation examples additional methods available to continue building your chat messaging application. https://github.com/socketio/socket.io\r\n\r\nIn Summary, we have a lot of resources available as developers to send data over the web, asynchronously. Front-End Frameworks like Angular help us to more easily make Ajax requests and communicate between client and server. However, as we continue to build more applications that rely on real-time data, it appears WebSockets could be a useful resource in helping us accomplish our domain. \r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}